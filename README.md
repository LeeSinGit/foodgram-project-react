
**FOODGRAM - FINAL PROJECT**

Описание реализации сайта.

##### * Реализация регистрации, авторизации, смены пароля и выхода из аккаунта.

Начнём работу поэтапно, с создания системы аутентификации сайта.

---

1. Активируем или создаём виртуальное окружение в корневой директории проекта.
   python -m venv venv
   source venv/Scripts/activate
2. Переходим в директорию backend и создаём проект foodgram.
   django-admin startproject foodgram
3. Создаём приложение api и users.
   django-admin startapp api
   django-admin startapp users
   Удаляем не нужные файлы и приступаем к коду.

Файл settings.py:

```
import os

from dotenv import load_dotenv
load_dotenv()

DATABASES = {
    'default': {
        'ENGINE': os.getenv('DB_ENGINE', default='django.db.backends.postgresql'),
        'NAME': os.getenv('DB_NAME', default='postgres'),
        'USER': os.getenv('POSTGRES_USER', default='postgres'),
        'PASSWORD': os.getenv('POSTGRES_PASSWORD', default='postgres'),
        'HOST': os.getenv('DB_HOST', default='db'),
        'PORT': os.getenv('DB_PORT', default=5432),
    }
}
```

*Описание.*

* Данные для подключения к базе данных передаются с помощью библиотеки *python-dotenv.* Так же задаются стандартные значения для параметров подключения к базе данных *PostgreSQL* в случае, если они не указаны в файле окружения (`.env`). Это позволяет установить значения по умолчанию, которые будут использоваться, если не заданы конкретные параметры в файле окружения.

```
ALLOWED_HOSTS= [
    '127.0.0.1',
    'host.docker.internal',
    'localhost',
    'backend',
]
```

*Описание.*

`ALLOWED_HOSTS` - список хостов (доменных имен), которые разрешены для доступа к Django приложению. Он используется для безопасности, чтобы ограничить, какие хосты могут делать запросы к вашему приложению. Если запрос приходит с хоста, который не указан в списке `ALLOWED_HOSTS`, Django будет блокировать доступ и возвращать ошибку "Bad Request (400)".

* `'127.0.0.1'` - это разрешает доступ с локального хоста.
* `'host.docker.internal'` - это разрешает доступ с хоста Docker (если приложение запущено в контейнерах).
* `'localhost'` - разрешает доступ с localhost.
* `'backend'` - разрешает доступ с хоста, который имеет имя `backend`.

```
STATIC_URL ='/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')

STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

MEDIA_URL='/media/'
MEDIA_ROOT= os.path.join(BASE_DIR, 'media')
```

*Описание.*

Эти настройки в Django отвечают за обработку статических файлов (например, CSS, JavaScript, изображения) и медиа-файлов (например, загруженные пользователем изображения).

1. `STATIC_URL` - это URL-префикс, который будет добавлен к путям к статическим файлам. Например, если `STATIC_URL` установлен как `'/static/'`, то все статические файлы будут доступны по URL вида `http://ваш_сайт/static/...`.
2. `STATIC_ROOT` - это абсолютный путь к директории, в которой будут собраны статические файлы для развёртывания. При использовании команды `collectstatic` Django копирует все статические файлы из приложений и других источников в эту директорию для последующего использования в продакшене.
3. `STATICFILES_DIRS` - это список дополнительных директорий, из которых Django будет брать статические файлы. В вашем случае, директория `'static'` в корне проекта указана как дополнительный источник статических файлов.
4. `MEDIA_URL` и `MEDIA_ROOT` - аналогично для медиа-файлов. `MEDIA_URL` - это URL-префикс для медиа-файлов, а `MEDIA_ROOT` - абсолютный путь к директории, где будут храниться загруженные медиа-файлы.

Когда Django-приложение работает, статические файлы (CSS, JavaScript и другие) будут обслуживаться через `STATIC_URL`, а медиа-файлы (изображения и прочее, загруженное пользователями) - через `MEDIA_URL`.

* Конфигурация `REST_FRAMEWORK`, `AUTH_USER_MODEL` и `DJOSER` в Django относится к настройкам, связанным с аутентификацией, авторизацией и обработкой пользовательских данных в RESTful API.

```
REST_FRAMEWORK = {
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticatedOrReadOnly",
    ],
'DEFAULT_AUTHENTICATION_CLASSES': [
         'rest_framework.authentication.TokenAuthentication',
    ],
}
```

*Описание.*

`REST_FRAMEWORK`:

1. `DEFAULT_PERMISSION_CLASSES`: Определяет классы разрешений по умолчанию для доступа к представлениям (views) API. В данном случае, используется `IsAuthenticatedOrReadOnly`, который позволяет аутентифицированным пользователям выполнять любые действия (создание, обновление, удаление), а неаутентифицированным - только чтение.
2. `DEFAULT_AUTHENTICATION_CLASSES`: Определяет классы аутентификации по умолчанию. Здесь используется `TokenAuthentication`, который позволяет пользователям аутентифицироваться с помощью токенов.

* ```
  AUTH_USER_MODEL='users.User'
  ```

  Описание.

1. `AUTH_USER_MODEL`: Указывает на модель пользователя, используемую в приложении. В данном случае, `users.User` указывает на модель пользователя, определенную в приложении `users`.

```
DJOSER= {
    "LOGIN_FIELD": "email",
    "SERIALIZERS": {
        "user": "api.serializers.UserSerializer",
        "user_list": "api.serializers.UserSerializer",
        "current_user": "api.serializers.UserSerializer",
        "user_create": "api.serializers.UserSerializer",
    },
}
```

*Описание.*

`DJOSER`:

* `LOGIN_FIELD`: Указывает поле, по которому пользователь будет аутентифицироваться при входе. В данном случае, используется `"email"`, что означает, что пользователь будет входить в систему с помощью адреса электронной почты.
* `SERIALIZERS`: Определяет сериализаторы, используемые для разных операций с пользователями. Здесь указаны сериализаторы для создания, просмотра и обновления пользователя. В данном случае, используется сериализатор `api.serializers.UserSerializer`.

В целом, эти настройки определяют, как будут происходить аутентификация, авторизация и работа с данными пользователей в RESTful API. `TokenAuthentication` предоставляет способ аутентификации пользователей с использованием токенов, а `IsAuthenticatedOrReadOnly` позволяет только аутентифицированным пользователям выполнять действия, отличные от чтения данных. `AUTH_USER_MODEL` позволяет определить, какая модель пользователя будет использоваться в приложении. `DJOSER` предоставляет настройки для работы с пользователями, включая определение поля для входа, а также сериализаторы для работы с данными пользователей.

---

**Файл models.py (backend/users/models.py)**

Через AbstractUser переопределяем стандартную модель user, чтобы указать правильные параметры из ТЗ.

Изменения в модели пользователя (`User`) включают следующее:

1. Добавление дополнительных полей:
   * `email`: Адрес электронной почты пользователя, с уникальным значением.
   * `username`: Никнейм пользователя, с уникальным значением и дополнительной валидацией.
   * `first_name`: Имя пользователя.
   * `last_name`: Фамилия пользователя.
   * `password`: Пароль пользователя.
2. Связи с группами и разрешениями:
   * `groups`: Связь с группами, к которым принадлежит пользователь.
   * `user_permissions`: Связь с конкретными разрешениями для пользователя.
3. Методы и метаданные:
   * `Meta`: Определение метаданных модели, таких как название, порядок сортировки и дополнительные ограничения.
   * `__str__`: Переопределение метода для отображения модели в виде строки.

---

**Файл views.py (backend/api/views.py)**

*UserViewSet*

1. Registration (POST) :

* При выполнении HTTP POST запроса на эндпоинт `/api/users/` (что соответствует операции регистрации) вызывается метод `create()` класса `DjoserUserViewSet` (наследуется из библиотеки Djoser).
* Метод `create()` использует сериализатор `UserSerializer` для валидации и создания нового пользователя на основе предоставленных данных.
* Ваш сериализатор `UserSerializer` определяет метод `create()`, который создает нового пользователя и сохраняет его в базу данных. После успешного создания возвращается сериализованные данные нового пользователя.

  2. Get User List (GET) :
* При выполнении HTTP GET запроса на эндпоинт `/api/users/` (получение списка пользователей) вызывается метод `list()` класса `DjoserUserViewSet`.
* Метод `list()` получает список всех пользователей из базы данных и передает их в сериализатор `UserSerializer` для преобразования в формат JSON. Затем возвращается список сериализованных пользователей.

3. Retrieve User (GET) :

* При выполнении HTTP GET запроса на эндпоинт `/api/users/{user_id}/` (получение конкретного пользователя) вызывается метод `retrieve()` класса `DjoserUserViewSet`.
* Метод `retrieve()` получает конкретного пользователя из базы данных по указанному `user_id` и передает его в сериализатор `UserSerializer`. Затем возвращается сериализованный пользователь.
